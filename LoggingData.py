# -*- coding: utf-8 -*-

"""
LoggingData.py
"""
import datetime as dt
import GTC

DEFAULT_TIME = dt.datetime.now()
QUANT_SHORT_ALIAS = {'Temperature': 'T',
                     'Rel Humidity': 'RH',
                     'Pressure':  'Pr',
                     'Flow Rate': 'FR',
                     'Power': 'Po'}
QUANT_LONG_ALIAS = {'T': 'Temperature',
                    'RH': 'Rel Humidity',
                    'Pr':  'Pressure',
                    'FR': 'Flow Rate',
                    'Po': 'Power'}


class Measurement:
    """
    A class to capture a single timestamped reading of a quantity.
    """
    def __init__(self, quantity='', value=None, unit='', timestamp=DEFAULT_TIME,
                 raw=True):
        """
        Arguments:
            quantity (str) - description of measurement (e.g. 'Temperature'),
            value (float) - numerical representation of measurement,
            unit (str) - description of measurement unit,
            timestamp (datetime)- a datetime object.
            raw (bool) - A flag to indicate if data is raw/uncorrected
                (default True)

        examples:
            meas1 = Measurement('T', 21.5, 'degC', <now>)
            meas2 = Measurement('P', 1013.5, 'mbar', <later>)
            meas3 = Measurement('RH', 55.4, '%RH', <soon>, raw=False)
        """
        # NOTE: Allow for GTC representation of values -
        #   Need members self.uncert snd self.dof
        self.quantity = quantity
        self.value = value
        self.unit = unit
        self.timestamp = timestamp
        self.raw = raw

    def new_val(self, val):
        """
        Create a new Measurement object where the value has been changed to val.

        The returned Measurement object always has raw=False,
        since it no longer represents the original data.

        Example:
            new_meas1 = meas1.new_val(<GTC.ureal>)

        :returns a Measurement object.
        """
        return Measurement(self.quantity, val, self.unit, self.timestamp,
                           raw=False)


class Calibration:
    """
    Encapsulate calibration info.
    """
    def __init__(self, date, rep_no, factor, offset):
        """
        :param rep_no: (str) - Calibration report No.
        :param date: (datetime) - Calibration date.
        :param factor: (GTC.ureal) - Correction factor.
        :param offset: (GTC.ureal) - Correction offset.
        """
        self.cal_date = date
        self.report_no = rep_no
        self.correction = {'factor': factor, 'offset': offset}


class DataReading:
    """
    A class to encapsulate 'smart' raw readings from a sensor instrument.

    A DataReading instance is the output from a sensor generated by a single
    reading 'request'. It consists of one or more Measurement instances,
    the generating equipment id and the associated logging site id.
    """
    def __init__(self, measurements, equip_id=None, log_site_id=None):
        """
        Arguments:
            equip_id (int) -  An identifier for the monitoring sensor
                (T/RH probe,  flow meter, barometer....),
            measurements (list of Measurement objects) - see Measurement()
                class definition,
            log_site_id (int) - An identifier for the logging site.

        Example:
            raw_reading = DataReading(<T_and_RH_probe_id>, [meas1, meas2],
            <screened_room1_id>)
        """
        self.equip_id = equip_id
        self.measurements = measurements
        self.site_id = log_site_id

    def correct(self):
        """
        Return a new DataReading instance where the measurements are corrected.

        Example:
            cor_reading = raw_reading.correct()

        :returns a new DatReading object.
        """
        corrected_measurements = []
        for meas in self.measurements:
            if meas.raw is False:  # Don't correct non-raw data
                corrected_measurements.append(meas)
            else:
                calibration = self.get_correction(meas)
                cor_factor = calibration.correction['factor']
                offset = calibration.correction['offset']
                corrected_val = meas.value*cor_factor + offset
                corrected_measurements.append(meas.new_val(corrected_val))

        return DataReading(self.equip_id, corrected_measurements, self.site_id)

    def export_to_db(self):
        """
        Write to 'Data for site' table -
        Update each data column with corresponding raw value,
        matched by measurement.quantity string.
        """
        pass

    def readline_from_calibration_table(self, equip, quant, cor_type, date):
        """
        Read 1 line FROM 'Calibrations'table ORDERED BY column'Cal_Date' DESC, WHERE
        column'Equip_No'=equip AND column'Parameter'=quant AND
        column'Correction_Type'='cor_type' AND column'Date'<date

        Return line as a dict where column headings are the keys.

        Example lines:
        |Cal_Id|Cal_Date |Equip_No|Report_No|Parameter   |Correction_Type |Value  |Uncert|DoF|
        ----------------------------------------------------------------------------------
        |1     |1/01/2020|1       |21999    |Temperature |factor          |1.0011 |5.2e-3|15 |
        |2     |1/01/2020|1       |21999    |Temperature |offset          |-0.11  |0.05  |12 |
        |3     |2/03/2020|1       |595      |Rel Humidity|factor          |1      |0     |inf|
        |4     |2/03/2020|1       |595      |Rel Humidity|offset          |2.52   |0.11  |21 |
        """
        line = {}  # default dict
        return line

    def get_correction(self, meas):
        """
        Read calibration parameters from 'Calibrations' table determined by the
        measurement data in meas.

        :param meas: (Measurement obj) - single measurement data.
        :return: (Calibration obj) - Includes GTC.ureals of correction-factor
             and offset, calibration date and report no.
        """
        equip = self.equip_id
        quant = meas.quantity
        date = meas.timestamp

        line = self.readline_from_calibration_table(equip, quant, 'factor', date)
        val_fact = line['Value']
        unc_fact = line['Uncert']
        dof_fact = line['DoF']
        cal_date = line['Date']
        rep_no = line['Report No']
        fact = GTC.ureal(val_fact, unc_fact, dof_fact)

        line = self.readline_from_calibration_table(equip, quant, 'offset', date)
        val_offs = line['Value']
        unc_offs = line['Uncert']
        dof_offs = line['DoF']
        offs = GTC.ureal(val_offs, unc_offs, dof_offs)

        cal = Calibration(date=cal_date, rep_no=rep_no,
                          factor=fact, offset=offs)
        return cal
