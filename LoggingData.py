# -*- coding: utf-8 -*-

"""
LoggingData.py
"""
import datetime as dt
import GTC
import sqlite3

DB_NAME = 'sensorsData.db'  # CHECK DB NAME IS CORRECT!
DEFAULT_TIME = dt.datetime.now()
TIME_FORMAT = "%d-%m-%Y %H:%M:%S"

QUANT_SHORT_ALIAS = {'Temperature': 'T',
                     'Rel Humidity': 'RH',
                     'Pressure':  'Pr',
                     'Flow Rate': 'FR',
                     'Power': 'Po'}
QUANT_LONG_ALIAS = {'T': 'Temperature',
                    'RH': 'Rel Humidity',
                    'Pr':  'Pressure',
                    'FR': 'Flow Rate',
                    'Po': 'Power'}


class Measurement(object):
    """
    A class to capture a single timestamped reading of a quantity.
    """
    def __init__(self, quantity='', value=None, unit='', timestamp=DEFAULT_TIME,
                 raw=True):
        """
        Arguments:
            quantity (str) - description of measurement (e.g. 'Temperature'),
            value (float) - numerical representation of measurement,
            unit (str) - description of measurement unit,
            timestamp (datetime)- a datetime object.
            raw (bool) - A flag to indicate if data is raw/uncorrected
                (default True)

        examples:
            meas1 = Measurement('T', 21.5, 'degC', <now>)
            meas2 = Measurement('P', 1013.5, 'mbar', <later>)
            meas3 = Measurement('RH', 55.4, '%RH', <soon>, raw=False)
        """
        # NOTE: Allow for GTC representation of values -
        #   Need members self.uncert snd self.dof
        self.quantity = quantity
        self.value = value
        self.unit = unit
        self.timestamp = timestamp
        self.raw = raw

    def new_val(self, val):
        """
        Create a new Measurement object where the value has been changed to val.

        The returned Measurement object always has raw=False,
        since it no longer represents the original data.

        Example:
            new_meas1 = meas1.new_val(<GTC.ureal>)

        :returns a Measurement object.
        """
        return Measurement(self.quantity, val, self.unit, self.timestamp,
                           raw=False)


class Calibration(object):
    """
    Encapsulate calibration info.
    """
    def __init__(self, date, rep_no, factor, offset):
        """
        :param rep_no: (str) - Calibration report No.
        :param date: (datetime) - Calibration date.
        :param factor: (GTC.ureal) - Correction factor.
        :param offset: (GTC.ureal) - Correction offset.
        """
        self.cal_date = date
        self.report_no = rep_no
        self.correction = {'factor': factor, 'offset': offset}


class DataReading(object):
    """
    A class to encapsulate 'smart' raw readings from a sensor instrument.

    A DataReading instance is the output from a sensor generated by a single
    reading 'request'. It consists of one or more Measurement instances,
    the generating equipment id and the associated logging site id.

    The timestamp of a DataReading defaults to that of the first
    Measurement.
    """
    def __init__(self, measurements, equip_id=None, log_site_id=None):
        """
        Arguments:
            equip_id (int) -  An identifier for the monitoring sensor
                (T/RH probe,  flow meter, barometer....),
            measurements (list of Measurement objects) - see Measurement()
                class definition,
            log_site_id (int) - An identifier for the logging site.

        Example:
            raw_reading = DataReading(<T_and_RH_probe_id>, [meas1, meas2],
            <screened_room1_id>)
        """
        self.equip_id = equip_id
        self.measurements = measurements
        self.site_id = log_site_id
        """
        Default to using 1st measurement's timestamp
        - in practice they'd probably be almost coincident anyway:
        """
        self.timestamp = measurements[0].timestamp

    def correct(self):
        """
        Return a new DataReading instance where the measurements are corrected.

        Example:
            cor_reading = raw_reading.correct()

        :returns a new DatReading object.
        """
        corrected_measurements = []
        for meas in self.measurements:
            if meas.raw is False:  # Don't correct non-raw data
                corrected_measurements.append(meas)
            else:
                calibration = self.get_correction(meas)
                cor_factor = calibration.correction['factor']
                offset = calibration.correction['offset']
                corrected_val = meas.value*cor_factor + offset
                corrected_measurements.append(meas.new_val(corrected_val))

        return DataReading(self.equip_id, corrected_measurements, self.site_id)

    def export_to_db(self, table):
        """
        Write to table 'Data for site <n>' -
        Update each data column with corresponding raw value,
        matched by measurement.quantity string.
        """
        conn = sqlite3.connect(DB_NAME)
        curs = conn.cursor()
        data_str = []
        date = self.timestamp.strftime(TIME_FORMAT)
        for m in self.measurements:
            # Example data_str entry: '[T: 21.02, 0, inf / deg C]': m.quantity
            data_str.append('[{}, {}, {} / {}]'.format(m.value, 0, 'inf', m.unit))
        curs.execute("INSERT INTO ? (Date, Equip_no, ?, ?) VALUES (?, ?, ?, ?)",
                     (table, self.measurements[0].quantity, self.measurements[1].quantity,
                      date, self.equip_id, data_str[0], data_str[1]))
        conn.close()

    @staticmethod
    def readrow_from_calibration_table(equip, quant, cor_type, date):
        """
        Return row as a dictionary where column headings are the keys.

        Example rows:
        |Cal_Id|Cal_Date |Equip_No|Report_No|Parameter   |Correction_Type |Value(v,u,df)        |
        -----------------------------------------------------------------------------------------
        |1     |1/01/2020|1       |21999    |Temperature |factor          |[1.0011, 5.2e-3, 15] |
        |2     |1/01/2020|1       |21999    |Temperature |offset          |[-0.11, 0.05, 12]    |
        |3     |2/03/2020|1       |595      |Rel Humidity|factor          |[1, 0, inf]          |
        |4     |2/03/2020|1       |595      |Rel Humidity|offset          |[2.52, 0.11, 21]     |
        """
        conn = sqlite3.connect(DB_NAME)
        curs = conn.cursor()
        # Get column headings:
        curs.execute("SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = Calibrations")
        headings = curs.fetchone()

        q1 = "SELECT * FROM Calibrations WHERE Equip_No=(?) AND Parameter=(?) AND Correction_Type=(?)"
        q2 = " AND Cal_Date<(?) ORDER BY Cal_Date DESC LIMIT 1"
        query = q1 + q2
        curs.execute(query, (equip, quant, cor_type, date))
        row = curs.fetchone()
        conn.close()
        result = dict(zip(headings, row))
        return result

    def get_correction(self, meas):
        """
        Read calibration parameters from 'Calibrations' table determined by the
        measurement data in meas.

        :param meas: (Measurement obj) - single measurement data.
        :return: (Calibration obj) - Includes GTC.ureals of correction-factor
             and offset, calibration date and report no.
        """
        equip = self.equip_id
        quant = meas.quantity
        date = meas.timestamp

        line = self.readrow_from_calibration_table(equip, quant, 'factor', date)
        val_fact = line['Value']
        unc_fact = line['Uncert']
        dof_fact = line['DoF']
        cal_date = line['Date']
        rep_no = line['Report No']
        fact = GTC.ureal(val_fact, unc_fact, dof_fact)

        line = self.readrow_from_calibration_table(equip, quant, 'offset', date)
        val_offs = line['Value']
        unc_offs = line['Uncert']
        dof_offs = line['DoF']
        offs = GTC.ureal(val_offs, unc_offs, dof_offs)

        cal = Calibration(date=cal_date, rep_no=rep_no,
                          factor=fact, offset=offs)
        return cal
